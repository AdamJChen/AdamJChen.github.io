---
title: "MQTT"
layout: post
---

I've been reading about a common communication protocol in IoT called MQTT, and I just wanted to summarize some things I've learned recently. 
It's commonly used in IoT because it's lightweight and it was designed for devices with limited resources or networks with limited bandwith. This is greate for IoT since it allows quick, real time message passing and many to many communications.
MQTT also has Quality of Service built into it unlike HTTP that requires the application layer to take care reliability of message delivery. This is handy for situations where a device might be located in a space with poor connectivity (Think agriculture applications).

### Protocol Architecture
Something about MQTT that I thought was pretty nifty was the Publish-Subscribe model. Unlike HTTP which is based on a client server message relationship, there's a "middle man" between communicating clients call the broker.
It's like two kids that have a crush on each other but are too shy to talk directly, so they have a a friend do all the note passing for them.
<img 
     style="display: block; 
           margin-left: auto;
           margin-right: auto;
           width: 30%;"
     src="https://ahchealthenewscdn.azureedge.net/wp-content/uploads/2018/12/crush-505x329.jpg" 
     width="300" 
     height="300" 
  />
The two clients talking to each other can either be a publisher (sending messages) or a subscriber (reciving messages). This decoupling of the publisher and the subscriber means that they don't have to know about each other. Because of this, the scalability
of the application becomes simplifed. This is beneficial for systems that are connected to many devices, as messages are in a queue to be recieved rather than waiting on a specific server to be available. Moreover, because the broker is mediating message passing, messaging can now be asyncronous. This is good news for devices with intermittent connectivity. 
Even if the connection to the device is lost, the device is able to send the message to the broker when the connection has been reestablished. 
Here's a graphic of MQTT in action that I took from the [Wikipedia page](https://en.wikipedia.org/wiki/MQTT) for MQTT:
<img 
     style="display: block; 
           margin-left: auto;
           margin-right: auto;
           width: 30%;"
     src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/MQTT_protocol_example_without_QoS.svg/1280px-MQTT_protocol_example_without_QoS.svg.png" 
     width="400" 
     height="600" 
  />
The image above reads from the top to the bottom (starting with connect). You can see that clients can act as both Subscribers and Publishers in this architecture.

### Quality of Service (QoS) Levels
In MQTT (Message Queuing Telemetry Transport), Quality of Service (QoS) levels define the reliability and delivery guarantees for messages exchanged between clients and the broker. MQTT supports three levels of QoS, allowing publishers and subscribers to specify the level of assurance they require regarding message delivery. Here's an explanation of each QoS level:
1. QoS 0 (At most once)

    Description: Also known as "fire and forget," this is the lowest level of assurance. Messages are delivered at most once, without any acknowledgment or retry mechanism.
    Characteristics:
        The message is published by the client and delivered to the broker.
        The broker sends the message to all subscribed clients without acknowledgment.
        There is no guarantee that the message will be delivered to the subscribers.
        Messages can be lost if there are network issues or if the subscriber is offline.
    Use Cases:
        Best-effort messaging where occasional message loss is acceptable.
        Applications where message delivery is less critical or time-sensitive.

2. QoS 1 (At least once)

    Description: This level ensures that messages are delivered at least once, potentially resulting in duplicates. The sender receives an acknowledgment (PUBACK) from the recipient.
    Characteristics:
        The message is published by the client and delivered to the broker.
        The broker acknowledges receipt of the message (PUBACK).
        If the broker doesn't receive the acknowledgment within a timeout period, it resends the message.
        Subscribers may receive duplicate messages, but message loss is minimized.
    Use Cases:
        Scenarios where occasional duplicate messages are acceptable but message loss is not.
        Reliable delivery of non-critical data where duplicates can be deduplicated at the application level.

3. QoS 2 (Exactly once)

    Description: This is the highest level of assurance, ensuring that messages are delivered exactly once. It involves a four-step handshake process between the publisher, broker, and subscriber.
    Characteristics:
        The message is published by the client and delivered to the broker.
        The broker stores the message until it receives acknowledgment (PUBREC) from the subscriber.
        Upon receiving the acknowledgment, the broker sends a confirmation (PUBREL) to the subscriber.
        The subscriber acknowledges the confirmation (PUBCOMP).
        This level guarantees that each message is delivered exactly once and in the correct order, eliminating duplicates and ensuring no message loss.
    Use Cases:
        Critical applications where message duplication is unacceptable, such as financial transactions or control systems.
        Situations where ensuring strict message ordering and delivery exactly once is essential.

### Last Will and Testament (LWT)
The last topic I want to summarize is the Last Will and Testament (LWT) feature. LWT allows clients to specify a message that the broker will publish in case the client has an unexpected disconnection. This feature us useful for notifying other devices in the system that the client is disconnected.
